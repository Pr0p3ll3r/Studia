#include <targets\AT91SAM7.h>
#include "pcf8833u8_lcd.h"
#include <ctl_api.h>
#include <string.h>

#define BL PIOB_PER_P20
#define SW1 PIOB_PER_P24
#define SW2 PIOB_PER_P25
#define BUZ PIOB_PER_P19

void TIMER0_ISR () {
    TC0_SR; // na pocz¹tku pusty odczyt rejestru statusu - kasowanie flagi przerwania CPCS
    ADC_CR = 1<<1; // lub ADC_CR_START; // start konwersji na aktywnych kana³ach
    while ((ADC_SR & ADC_SR_EOC5) == 0) {} // dopóki flaga EOC5 jest rowna 0 (konwersja na kanale 5 nie zakooczy³a siê) czekaj
    int a = 20 + (ADC_CDR5 - 500)/5;
    char b[4];
    itoa(a, b, 10);
    LCDPutStr(b, 20, 20, LARGE, WHITE, BLACK);
    TC0_RC = 7500;
  }

void PIOB_przerwanie(){
     PIOB_ODSR ^= 1<<20;
  }

int main (){

InitLCD();
SetContrast(50);
LCDClearScreen();
PMC_PCER = 1<<3 | 1<<17 | 1<<12 | 1<<1; // Power management controller (s. 30 datasheet)
// konfiguracja ADC, konwersja wartoœci napiêcia z kana³u 3 przetwornika:
ADC_CR = 1 << 0; // lub ADC_CR_SWRST – to inny zapis tego samego – reset przetwornika
ADC_CHER = 1 << 5; // aktywowanie kana³ów na których ma byd przeprowadzona konwersja
ADC_IDR = 0xFFFFF; // œwiadomie wy³¹czamy przerwania od wszystkich zdarzeo(Ÿróde³) z ADC
ADC_MR = (23<<ADC_MR_PRESCAL_BIT) | (2<<ADC_MR_STARTUP_BIT) | (1<<ADC_MR_SHTIM_BIT);
// w rejestrze ADC_MR mo¿liwe równie¿ ustawienia ni¿szej rozdzielczoœci

//Zadanie 2
ctl_global_interrupts_disable();  //globalne wy³¹czenie przerwañ

PMC_PCER = PMC_PCER_PIOA | PMC_PCER_TC0; // za³¹czenie zegara PIOA USART0 TIMER0 

TC0_CCR = TC0_CCR_CLKDIS;    //trzeba wy³¹czyæ zegar
TC0_IDR = 0xFF;  // wy³¹czyæ wszystkie przerwania strona 421
TC0_SR;  //PUSTY ODCZYT, czytamy, ale wartoœci nigdzie nie zapisujemy ///// odczyt na pusto rejestru TC_SR, jak siê go czyta to siê zeruje
// wybranie preskalera TIMER_CLOCK1 = MCK/2, 389
TC0_CMR = (1<<2); // wybieramy preskaler /1024 czyli MCK/8, preskaler 5 /// póŸniej ustawimy bit CPCTRG - rc compare --> reset counter i star clock //  skracamy licznik
TC0_CMR = (1<<2) | TC0_CMR_CPCTRG;  // strona 409 MCK/1024 i reset licznika przy porównaniu wartoœci licznika z rejestrem RC

TC0_RC = 7500;

ctl_set_isr(12,1,CTL_ISR_TRIGGER_FIXED,TIMER0_ISR,0);   // konfiguracja przerwania od timera, powi¹zanie procedury obs³ugi przerwania ze Ÿród³em
TC0_IER = TC0_IER_CPCS;   // za³¹czenie Ÿród³a przerwania od porównania wartoœci licznika z rejestrem RC
ctl_unmask_isr(12);   // zezwolenie na przerwania od timera (wy¹czenie procedury obs³ugi przerwania)
//start TIMERA
TC0_CCR = TC0_CCR_CLKEN | TC0_CCR_SWTRG; // za³¹czenie zegara | reset licznika

ctl_global_interrupts_enable(); //zezwolenie na globalne przerwania

/*
Zadanie 3
PIOB_PER = BL | BUZ;                // Pin Enable Register - za³¹czenie pinu P20
PIOB_OER = BL | BUZ;                // Output Enable Register - ustawienie Pinu20 w tryb wyjœciowy  OSR - sprawdzanie stanu     ODR - disable                     
PIOB_PUDR = BL | BUZ;               // Pull Up Disable Register - PUER, PUSR - wy³¹czenie rezystora podci¹gaj¹cego
PIOB_PUDR = BL | BUZ;               // Pull Up Disable Register - PUER, PUSR - wy³¹czenie rezystora podci¹gaj¹cego
PIOB_OWER = BL;
  
ctl_global_interrupts_disable();
ctl_set_isr(3,1,CTL_ISR_TRIGGER_FIXED,PIOB_przerwanie,0); 
PIOB_IER = 1<<24|1<<25; //w³¹czenie przerwan od dwóch linii P25 i P24
ctl_unmask_isr(3);
ctl_global_interrupts_enable();
*/
while(1){
  
}

//Zadanie 1
/*
while(1){
  ADC_CR = 1<<1; // lub ADC_CR_START; // start konwersji na aktywnych kana³ach
  while ((ADC_SR & ADC_SR_EOC5) == 0) {} // dopóki flaga EOC5 jest rowna 0 (konwersja na kanale 5 nie zakooczy³a siê) czekaj
  int a = 20 + (ADC_CDR5 - 500)/5;
  char b[4];
  itoa(a, b, 10);
  LCDPutStr(b, 20, 20, LARGE, WHITE, BLACK);
}
*/
}